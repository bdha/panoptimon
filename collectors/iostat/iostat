#!/usr/bin/env ruby

module Panoptimon
  module Collector
    class IOStat

      attr_reader :iostat, :flags, :opt

      def initialize (options={})
        @opt = options
        @iostat = opt[:iostat] || 'iostat'
      end

      def cmd
        cmd = [iostat, flags]

        if opt[:interval]
          cmd.push(opt[:interval].to_s)
          cmd.push(opt[:count].to_s) if opt[:count]
        end

        return cmd
      end

      def parse_header (l)
        head = l.chomp.split(/\s+/)
        head = Hash[*head.zip(0..(head.length-1)).flatten]
        want.values.find_all{|x| not(head[x])}.tap {|missed|
          warn "missing headers: "+ missed.join(', ') if missed.length > 0
        }
        o = {}; want.each {|k,v| o[k] = head[v] if head[v]}
        return o
      end

      def run
        p = IO.popen(cmd, 'r')

        2.times { x = p.readline until x == "\n" } # header + first sample

        puts '{}' # beep

        omap = nil

        until p.eof?
          l = p.readline("\n\n").split(/\n/)
          omap ||= parse_header(l[0])
          puts JSON::generate(Hash[*l.drop(1).map {|x|
            r = x.split(/\s+/)
            [r[0], # device name
              Hash[*omap.keys.map {|k| [k, r[omap[k]].to_f]}.flatten]]
          }.flatten])

        end
      end
      
      class OS_linux < Panoptimon::Collector::IOStat
        # -xd
        def flags; '-xd' ; end
        def want
          {
            'kb_read/s'  => 'rkB/s',
            'kb_write/s' => 'wkB/s',
            'rrqm/s'     => 'rrqm/s',
            'wrqm/s'     => 'wrqm/s',
            'reads/s'    => 'r/s',
            'writes/s'   => 'w/s',
            'avgrq-sz'   => 'avgrq-sz',
            'avgqu-sz'   => 'avgqu-sz',
            'await'      => 'await',
            'r_await'    => 'r_await',
            'w_await'    => 'w_await',
            'util'       => '%util',
          }
        end

      end
      class OS_freebsd < Panoptimon::Collector::IOStat::OS_linux; end  
      class OS_solaris < Panoptimon::Collector::IOStat
        # -xne
      end
      class OS_openbsd < Panoptimon::Collector::IOStat
        # default output format, -w required
      end
    end
  end
end

########################################################################
require 'panoptimon/util'

$stdout.sync = true # persistent process

require 'json'
opt = ARGV[0] ?
    JSON::parse(ARGV[0], {symbolize_names: true})
  : {interval: 1, count: 2}

os_class = Panoptimon::Collector::IOStat.const_get(
  'OS_' + Panoptimon::Util.os.to_s)
os_class.new(opt).run

